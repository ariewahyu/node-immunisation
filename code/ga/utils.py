import numpy as np

""" Utility functions """

def is_dominated_by(A, B):
    """ Check if 2D solution A is dominated by B. Assumes both dimension should be minimised"""
    return (A[0] >= B[0] and A[1] > B[1]) or (A[0] > B[0] and A[1] >= B[1])


def get_non_dominated(solutions):
    """ Filters out all dominated 2D solutions in the solution set and returns all nondominated ones """
    solutions.sort(key=lambda solution: solution['evaluation'])
    pareto_front = []

    pareto_front.append(solutions[0])
    i = 0
    j = 1
    while j < len(solutions):
        if not is_dominated_by(solutions[j]['evaluation'], solutions[i]['evaluation']):
            pareto_front.append(solutions[j])
            i = j
            j = i+1
        else:
            j += 1

    return pareto_front


def calculate_hyperspace_volume(rp, solutions):
    """ Calculate the dominated 2D hyperscace indicator bound by the reference point rp """

    non_dominated = get_non_dominated(solutions)
    points = set(s['evaluation'] for s in non_dominated)

    points = sorted(points)

    dominated_hyperspace = 0

    for i, _ in enumerate(points):
        if i == 0:
            dominated_hyperspace += (rp[0] - points[i][0]) * (rp[1] - points[i][1])
        else:
            dominated_hyperspace += (rp[0] - points[i][0]) * (points[i-1][1] - points[i][1])

    return dominated_hyperspace


def pareto_by_enumeration(objective_function, solutions_iterator):
    """ Find 2D pareto by full enumeration. Interates over all solutions generated by the passed iterator, and uses the passed in objective function """

    solutions = []
    for sol in solutions_iterator:
        s = {'solution': np.array(sol)}
        objective_function(s)
        solutions.append(s)

    return get_non_dominated(solutions)

